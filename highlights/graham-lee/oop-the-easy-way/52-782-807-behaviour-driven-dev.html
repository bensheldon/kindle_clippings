<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title></title>
  <link rel="stylesheet" href="/kindle_clippings/assets/bootstrap/bootstrap.min.css">
  <script src="/kindle_clippings/assets/bootstrap/bootstrap.bundle.min.js"></script>

  <!-- Don't list this on search engines -->
  <meta name="robots" content="noindex,follow" />
</head>

<body>
  <nav class="navbar navbar-expand-lg navbar-light bg-light sticky-top">
    <div class="container">
    <a class="navbar-brand" href="/kindle_clippings/">Kindle Clippings</a>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>
    <div class="collapse navbar-collapse" id="navbarNav">
      <ul class="navbar-nav">
        <li class="nav-item">
          <a class="nav-link" href="/kindle_clippings/">Highlights</a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="/kindle_clippings/books">Books</a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="/kindle_clippings/authors">Authors</a>
        </li>
      </ul>
    </div>
    </div>
  </nav>

  <div class="container">
  
<h1>OOP the Easy Way</h1>

<p>Behaviour-Driven Development marries the technical process of Test-Driven Development with the design concept of the ubiquitous language, by encouraging developers to collaborate with the rest of their team on defining statements of desired behaviour in the ubiquitous language and using those to drive the design and implementation of the objects in the solution domain. In that way, the statement of what the Goal Donor needs is also the statement of sufficiency and correctness - i.e. the description of the problem that needs solving is also the description of a working solution. This ends up looking tautological enough not to be surprising. Constructing Independent Objects The theme running through the above is that sufficiency is sufficient. When an object has been identified as part of the solution to a problem, and contributes to that solution to the extent needed (even if for now that extent is “demonstrate that a solution is viable”), then it is ready to use. There is no need to situate the object in a taxonomy of inherited classes - but if that helps to solve the problem, then by all means do it. There is no need to show that various objects demonstrate a strict subtype relationship and can be used interchangeably, unless solving your problem requires that they be used interchangeably. There is no need for an object to make its data available to the rest of the program, unless the problem can be better solved (or cheaper solved, or some other desirable property) by doing so. I made quite a big deal above of the open-closed principle, and its suggestion that the objects we build be “open to modification”. Doesn’t that mean anticipating the ways in which a system will change and making it possible for the objects to flex in those ways? To some extent, yes, and indeed that consideration can be valuable. If your problem is working out how much to bill snooker players for their time on the tables in your local snooker hall, then it is indeed possible that your solution will be used in the same hall on the pool tables, or in a different snooker hall. But which of those will happen first, will either happen soon? Those are questions to work with the Goal Donor and the Gold Owner (the person paying for the solution) on answering. Is it worth paying to solve this related problem now, or not? Regardless of the answer, the fact is that the objects are still ready to go to work as soon as they address the problem you have now. And there are other ways to address related problems anyway, which don’t require “future-proofing” the object designs to anticipate the uses to which they may be put. Perhaps your SnookerTable isn’t open to the extension of representing a pool table too, but the rest of the objects in your solution can send messages to a PoolPlayer in its stead. As the variant on the Open-Closed Principle above showed, these other objects could be ignorant of the game played on the table. Some amount of planning is always helpful, whether or not the plan turns out to be. The goal at every turn should be to understand how we get to what we now want from what we have now, not to already have that which we will probably want sometime. Maybe the easiest thing to do is to start afresh: so do that. <strong>— 52: 782-807</strong></p>



  </div>
</body>
</html>
