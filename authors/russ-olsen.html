<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <link rel="stylesheet" href="/kindle_clippings/assets/bootstrap/bootstrap.min.css">
  <script src="/kindle_clippings/assets/bootstrap/bootstrap.bundle.min.js"></script>

  <!-- Don't list this on search engines -->
  <meta name="robots" content="noindex,follow" />
</head>

<body>
  <nav class="navbar navbar-expand-lg navbar-light bg-light sticky-top">
    <div class="container">
    <a class="navbar-brand" href="/kindle_clippings/">Kindle Clippings</a>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>
    <div class="collapse navbar-collapse" id="navbarNav">
      <ul class="navbar-nav">
        <li class="nav-item">
          <a class="nav-link" href="/kindle_clippings/#authors">Authors</a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="/kindle_clippings/#books">Books</a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="/kindle_clippings/#clippings">Clippings</a>
        </li>
      </ul>
    </div>
    </div>
  </nav>

  <div class="container">
  <h1>Russ Olsen</h1>


  <h2>Eloquent Ruby (Addison-Wesley Professional Ruby Series)</h2>

  <ul>
    
      <li>If you feel like this technique has left you in a confusing maze of twisty passages,3 here are some signposts that can help. First, keep your goal firmly in mind. In our example, we wanted to make it easy to add paragraph-generating methods to StructuredDocument subclasses. Second, know when things happen. For example, when you load the StructuredDocument code, perhaps with this: require 'structured_document' You end up with the generic StructuredDocument class, which has the paragraph_type class method on it. A bit later (perhaps even on the very next line of code) you load the Instructions class: require 'instructions' As the Instructions class definition is getting executed, it will fire off calls to the paragraph_type method up in the StructuredDocument class. This will add methods with names like introduction, warning, and step to the Instructions class. Only when all of this defining is over do you make an instance of Instructions and call the generated methods. The third thing to know is that the value of self is at every stage of this process. This starts out relatively straightforward but gets a little hairy as you go along. The straightforward bit is in the superclass:</li>
    
      <li>The code that you never write will work forever.</li>
    
      <li>good workman also learns from the past. All too often when a new technology comes along—Ruby, for example—we tend to toss out the hard-won lessons of experience along with the old code. Take the time to learn from the smart people who came before you. You might start with Paul Graham’s 1993 book, On LISP. The entire text of this book is available at www.paulgraham.com/onlisp.html. It is worth reading even if you never type a single parenthesis of LISP. In many ways this book, especially the chapter on object equality, was inspired by: Bloch, J. Effective Java, Second Edition. Boston, MA: Addison-Wesley, 2008.</li>
    
      <li>Engineering is all about trade-offs. Just about every engineering decision involves getting something, but at a price,</li>
    
      <li>Now, a skeptic might observe that neither replace_firstname nor replace_lastcarmodelbought have added any particularly new capability to the FormLetter class.1 These two methods, however they are implemented, simply expose an existing feature of the FormLetter class in a slightly different package. So why should we bother? We bother because our users asked us to bother. If you reread my tale of intrigue and junk mail, you’ll see that it was the coders who were using the FormLetter class that asked for the convenience methods. Those methods make the code generating the form letters cleaner and easier for the people who count—the programmers who need to deal with it. One of the key values of the Ruby programming culture is that the look of the code matters. It matters because the people who use the code, read the code, and maintain the code matter. Good software engineering is all about making everyone’s job easier, not just because we want to go home on time but because we all want to turn out the best possible end product. So we add convenience methods, build method_missing methods, and go to enormous lengths to make our APIs easy to use because programmers with easy-to-use APIs tend to have the time to craft easy-to-use—and working—systems.</li>
    
      <li>Fixing this kind of location independence problem is cheap; knowing that you have the problem in the first place is priceless.</li>
    
  </ul>


  </div>
</body>
</html>
